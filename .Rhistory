fa.plot = ggplot(fa.res.df, aes(x = variable, y = y, fill = value)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
####### PCA ########
# # briefly examine the data
# apply(data.clean, 2, mean)
# apply(data.clean, 2, var)
# apply PCA
####### PCA ########
# Apply PCR to data
pr.out = prcomp(numerical.data, scale = TRUE)$rotation[1:19,1:6]
pr.res.df = melt(pr.out)
colnames(pr.res.df) = c("features","components","loadings")
pr.plot = ggplot(pr.res.df, aes(x = X2, y = X1, fill = value)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
library(gridExtra)
grid.arrange(fa.plot, pr.plot, nrow = 1)
colnames(fa.res.df)  = c("features","loadings","components")
fa.res.df
library(ggplot2)
library(reshape)
par(mfrow=c(1,3))
fa.res.df = melt(fa.res.rot.loading)
fa.res.df['y'] = rep(rownames(fa.res.rot.loading),6)
fa.res.df  = fa.res.df[order(fa.res.df$y),]
colnames(fa.res.df)  = c("components","loadings","features")
fa.res.df
library(fastICA)
set.seed(20)
ica = fastICA(data.clean, 6, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = TRUE)
ica
ica
View(ica)
ica = fastICA(numerical.data, 6, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = TRUE)
iCA$A
iCA$A
ica$A
set.seed(20)
ica = fastICA(numerical.data, 6, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = FALSE)
ica$A
ica$A.T
ica$A
S = cbind(sin((1:1000)/20), rep((((1:200)-100)/100), 5))
##### get mixing matrix
M = matrix(c(0.291, 0.6557, -0.5439, 0.5572), 2, 2)
##### plot ource signals
par(mfrow = c(1, 2))
plot(1:1000, S[,1], type = "l",xlab = "source 1",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
plot(1:1000, S[,2], type = "l", xlab = "source 2",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
##### mix the source signals to get the observed signals X
X = S %*% M
X = S %*% M
par(mfrow = c(1, 2))
plot(1:1000, X[,1], type = "l",xlab = "observation 1",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
plot(1:1000, X[,2], type = "l", xlab = "observation 2",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
##### apply ICA
library(fastICA)
set.seed(20)
latent = fastICA(X, 2, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = TRUE)
##### the estimated source signals are in S
par(mfrow = c(1, 2))
plot(1:1000, latent$S[,1], type = "l", xlab = "Esource 1",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
plot(1:1000, latent$S[,2], type = "l", xlab = "Esource 1",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
data$new_name
X = S %*% M
par(mfrow = c(1, 2))
plot(1:1000, X[,1], type = "l",xlab = "observation 1",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
plot(1:1000, X[,2], type = "l", xlab = "observation 2",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
##### apply ICA
library(fastICA)
set.seed(20)
latent = fastICA(X, 2, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = TRUE)
##### the estimated source signals are in S
par(mfrow = c(1, 2))
plot(1:1000, latent$S[,1], type = "l", xlab = "Esource 1",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
plot(1:1000, latent$S[,2], type = "l", xlab = "Esource 1",ylab="",cex.lab=1.5,cex.axis=1.5,lwd=2)
latent$A
latent$A %*& S
latent$A %* S
latent$A *%* S
latent$A
latent$A %*% S
S  %*%  latent$A
plot(S)
plot(X
)
??
?fastICA
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(data_features)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "ic", values_to = "loading")
??  could not find function "pivot_longer"
??pivot_longer
library(tidyr)
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(data_features)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "ic", values_to = "loading")
??str_glue
library(stringr)
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(data_features)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "ic", values_to = "loading")
library(stringr)
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(data_features)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "ic", values_to = "loading")
ica.loading
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(data_features)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "ic", values_to = "loading")
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(numerical.data)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "ic", values_to = "loading")
ica.loading
colnames(fa.res.df) = c("features","components","loadings")
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(numerical.data)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "components", values_to = "loading")
colnames(fa.res.df) = c("features","components","loadings")
library(stringr)
ica.loading
ica.plot = ggplot(pr.res.df, aes(x = X2, y = X1, fill = value)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(numerical.data)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "components", values_to = "loading")
colnames(ica.loading) = c("features","components","loadings")
ica.plot = ggplot(pr.res.df, aes(x = X2, y = X1, fill = value)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
ica.plot
ica.plot
ica.plot = ggplot(pr.res.df, aes(x = components, y = features, fill = value)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
ica.plot
colnames(ica.loading) = c("features","components","values")
ica.plot = ggplot(pr.res.df, aes(x = components, y = features, fill = value)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
ica.plot
ica.loading
source("~/OneDrive/Documents/MyOversea/Cass Study/machine learning/machine-learning-gp2/main.R")
# import libraries
library(dplyr)
library(GGally)
library(corrplot)
library(lubridate)
library(forcats)
library(readr)
library(reshape)
library(polycor)
# import data
data.ori = read.csv("customer-personality.csv")
# summary of data
str(data.ori)
# check for NA
sum(is.na(data.ori))
# check which columns contain NA
apply(is.na(data.ori), 2, which)
# remove NA rows
data.clean = data.ori[which(!is.na(data.ori$Income)),]
str(data.clean)
sum(is.na(data.clean))
# remove outliers from income and birth year
## income
data.clean <- data.clean[!(data.clean$Income >=200000),]
## birth year
data.clean <- data.clean[!(data.clean$Year_Birth <=1901),]
# converting 'Education', 'Marital status', and 'Dt_Customer' variables to categorical variables
## Education - Creating 3 categories
data.clean$Education[data.clean$Education == "Basic"] <- "1"
data.clean$Education[data.clean$Education == "Graduation"] <- "2"
data.clean$Education[data.clean$Education == "2n Cycle"] <- "3"
data.clean$Education[data.clean$Education == "Master"] <- "3"
data.clean$Education[data.clean$Education == "PhD"] <- "3"
data.clean$Education <- as.numeric(data.clean$Education)
## Marital Status - Creating 2 categories of Single and together
data.clean$Marital_Status[data.clean$Marital_Status == "Absurd"] <- 0
data.clean$Marital_Status[data.clean$Marital_Status == "Alone"] <- 0
data.clean$Marital_Status[data.clean$Marital_Status == "YOLO"] <- 0
data.clean$Marital_Status[data.clean$Marital_Status == "Single"] <- 0
data.clean$Marital_Status[data.clean$Marital_Status == "Together"] <- 1
data.clean$Marital_Status[data.clean$Marital_Status == "Married"] <- 1
data.clean$Marital_Status[data.clean$Marital_Status == "Divorced"] <- 0
data.clean$Marital_Status[data.clean$Marital_Status == "Widow"] <- 0
data.clean$Marital_Status <- as.numeric(data.clean$Marital_Status)
## Dt_customer
data.clean$Dt_Customer <- dmy(data.clean$Dt_Customer)
data.clean$Dt_Customer <- year(data.clean$Dt_Customer)
data.clean$Dt_Customer <- as.factor(data.clean$Dt_Customer)
data.clean$Dt_Customer <- fct_collapse(data.clean$Dt_Customer,
"3" = "2014",
"1" = "2012",
"2" = "2013")
data.clean$Dt_Customer <- as.numeric(levels(data.clean$Dt_Customer))[data.clean$Dt_Customer]
# Adding Age variable
data.clean$Age <- (2015 - data.clean$Year_Birth)
# filter numerical columns
numerical.data = data.clean[, c(3:21)]#:ncol(data.ori))]
str(numerical.data)
# plot correlation matrix
# corrplot(cor(numerical.data), tl.col = "black", diag = FALSE,
# method = 'number', type = 'upper')
# cor_1 <- round(cor(numerical.data, use = "pairwise.complete.obs"),2)
# corrplot.mixed(cor_1, lower = "number", upper = "ellipse", lower.col = "black", tl.cex=0.5)
corr_simple <- function(data=numerical.data,sig=0.5){
#convert data to numeric in order to run correlations
#convert to factor first to keep the integrity of the data - each value will become a number rather than turn into NA
df_cor <- data %>% mutate_if(is.character, as.factor)
df_cor <- df_cor %>% mutate_if(is.factor, as.numeric)
#run a correlation and drop the insignificant ones
corr <- cor(df_cor)
#prepare to drop duplicates and correlations of 1
corr[lower.tri(corr,diag=TRUE)] <- NA
#drop perfect correlations
corr[corr == 1] <- NA
#turn into a 3-column table
corr <- as.data.frame(as.table(corr))
#remove the NA values from above
corr <- na.omit(corr)
#select significant values
corr <- subset(corr, abs(Freq) > sig)
#sort by highest correlation
corr <- corr[order(-abs(corr$Freq)),]
#print table
print(corr)
#turn corr back into matrix in order to plot with corrplot
mtx_corr <- reshape2::acast(corr, Var1~Var2, value.var="Freq")
#plot correlations visually
corrplot(mtx_corr, is.corr=T, tl.col="black", method = 'number', na.label=" ", number.cex=0.8 ,tl.cex=0.8)
}
corr_simple()
# # inefficient to use this, too much data
# ggpairs(numerical.data)#, aes(color = class, alpha = 0.5))
######## Factor Analysis ########
### determine the number of factors of FA
# We want to identify the component of the correlation structure
# Remove Dt_customer for now
# data.clean$Dt_Customer <- NULL
library(EFA.dimensions)
fa.cor = POLYCHORIC_R(numerical.data)
fa.eigen = eigen(fa.cor)
fa.eigen$values
sum(fa.eigen$values)
cumsum(fa.eigen$values)/ncol(numerical.data) #
# use the scree plot
plot(fa.eigen$values, type = "b", ylab = "Eigenvalues", xlab = "Factor") # we choose 4
# plot(cumsum(fa.eigen$values)/17, type = "b", ylab = "Eigenvalues", xlab = "Factor") # we choose 4
##############################################
### factor analysis
# Choosing 6 as it explains 0.676 of the data
fa.res = factanal(x = numerical.data, factors = 6, rotation = "none") # factor = 4 because of our eigenvalues easlier
fa.res.loading = fa.res$loadings
##############################################
### factor rotation
fa.res = factanal(x = numerical.data, factors = 6, rotation = "promax")
# promax belongs to the oblique rotation?
print(fa.res, cut = 0.2)
# we only show the factors with a loading of higher than 0.2
# therefore only selecting the variables with large loading
# you can see that paragraph, sentence and wordm is with factor 1
##############################################
### factor scores # TODO: play around the rotation method
fa.res.rot = factanal(x = numerical.data, factors = 6, rotation = "promax", scores = "Bartlett")
head(fa.res.rot$scores)
summary(lm(Factor2 ~ Factor1, data = as.data.frame(fa.res.rot$scores)))
fa.res.rot.loading  = data.frame(fa.res.rot$loadings[1:19,1:6])
# draw the heatmap
library(ggplot2)
library(reshape)
par(mfrow=c(1,3))
fa.res.df = melt(fa.res.rot.loading)
fa.res.df['y'] = rep(rownames(fa.res.rot.loading),6)
fa.res.df  = fa.res.df[order(fa.res.df$y),]
colnames(fa.res.df)  = c("components","loadings","features")
fa.plot = ggplot(fa.res.df, aes(x = variable, y = y, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
# Apply PCR to data
pr.out = prcomp(numerical.data, scale = TRUE)$rotation[1:19,1:6]
pr.res.df = melt(pr.out)
colnames(pr.res.df) = c("features","components","loadings")
pr.plot = ggplot(pr.res.df, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
####### ICA ########
library(fastICA)
library(tidyr)
library(stringr)
set.seed(20)
ica = fastICA(numerical.data, 6, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = FALSE)
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(numerical.data)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "components", values_to = "loading")
colnames(ica.loading) = c("features","components","loadings")
ica.plot = ggplot(pr.res.df, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
####### Draw the loadings #########
library(gridExtra)
grid.arrange(fa.plot, pr.plot,ica.plot, nrow = 1)
fa.plot
##############################################
### factor analysis
# Choosing 6 as it explains 0.676 of the data
fa.res = factanal(x = numerical.data, factors = 6, rotation = "none") # factor = 4 because of our eigenvalues easlier
fa.res.loading = fa.res$loadings
#uniqueness = epsilon values
# loadings
# We have proportion variance explained by these loadings
# hypothesis test to see whether 4 factors are sufficient
# here, our p value is high therefore we don't reject that 4 factors are sufficient
##############################################
### factor rotation
fa.res = factanal(x = numerical.data, factors = 6, rotation = "promax")
# promax belongs to the oblique rotation?
print(fa.res, cut = 0.2)
# we only show the factors with a loading of higher than 0.2
# therefore only selecting the variables with large loading
# you can see that paragraph, sentence and wordm is with factor 1
##############################################
### factor scores # TODO: play around the rotation method
fa.res.rot = factanal(x = numerical.data, factors = 6, rotation = "promax", scores = "Bartlett")
head(fa.res.rot$scores)
summary(lm(Factor2 ~ Factor1, data = as.data.frame(fa.res.rot$scores)))
fa.res.rot.loading  = data.frame(fa.res.rot$loadings[1:19,1:6])
# draw the heatmap
library(ggplot2)
library(reshape)
par(mfrow=c(1,3))
fa.res.df = melt(fa.res.rot.loading)
fa.res.df['y'] = rep(rownames(fa.res.rot.loading),6)
fa.res.df  = fa.res.df[order(fa.res.df$y),]
colnames(fa.res.df)  = c("components","loadings","features")
fa.plot = ggplot(fa.res.df, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
####### PCA ########
# # briefly examine the data
# apply(data.clean, 2, mean)
# apply(data.clean, 2, var)
# apply PCA
####### PCA ########
# Apply PCR to data
pr.out = prcomp(numerical.data, scale = TRUE)$rotation[1:19,1:6]
pr.res.df = melt(pr.out)
colnames(pr.res.df) = c("features","components","loadings")
pr.plot = ggplot(pr.res.df, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
####### ICA ########
library(fastICA)
library(tidyr)
library(stringr)
set.seed(20)
ica = fastICA(numerical.data, 6, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = FALSE)
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(numerical.data)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "components", values_to = "loading")
colnames(ica.loading) = c("features","components","loadings")
ica.plot = ggplot(pr.res.df, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
####### Draw the loadings #########
library(gridExtra)
grid.arrange(fa.plot, pr.plot,ica.plot, nrow = 1)
v
fa.plot
pr.plot
ica.plot
ica.plot = ggplot(ica.loading, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
ica.plot
ica.loading
View(ica.loading)
names(numerical.data)
t(ica$A)
set.seed(20)
ica = fastICA(numerical.data, 6, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = FALSE)
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(numerical.data)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "components", values_to = "loading")
ica.loading
ica = fastICA(numerical.data, 6, fun = "logcosh", alpha = 1,
row.norm = FALSE, maxit = 200,
tol = 0.0001, verbose = FALSE)
t(ica$A))
t(ica$A)
ica.loading
range( ica.loading$loading )
numerical.data
ica
ica$A
??fastICA
ica = fastICA(numerical.data, 6, fun = "logcosh", alpha = 1,
row.norm = T, maxit = 200,
tol = 0.0001, verbose = FALSE)
ica.loading = data.frame(t(ica$A)) %>%
rename_with(~ str_glue("IC{seq(.)}")) %>%
mutate(variable = names(numerical.data)) %>%
pivot_longer(cols = starts_with("IC"), names_to = "components", values_to = "loading")
colnames(ica.loading) = c("features","components","loadings")
ica.plot = ggplot(ica.loading, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
ica.loading
ggplot(ica.loading, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
coord_fixed()
ggplot(ica.loading, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
scico::scale_fill_scico(palette = "cork", limits = c(-1,1))
coord_fixed()
ggplot(ica.loading, aes(x = components, y = features, fill = loadings)) +
geom_tile(color = "white",
lwd = 1.5,
linetype = 1) +
scale_fill_gradient(low='white',high='red')+
scico::scale_fill_scico(palette = "cork", limits = c(-1,1))
coord_fixed()
??scico
??scico
library('colorsapce')
install.packages('colorspace')
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
install.packages("colorspace")
